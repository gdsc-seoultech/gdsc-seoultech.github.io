---
layout: post
title: NestJS 2주차 스터디
date: 2022-01-08
author: ehrwk
description: 2주차 정리
categories: ["1st_term"]
tags: ["study"]
---

# 벡엔드 스터디 2주차

안녕하세요! 벡엔드 스터디원 윤희서 입니다.  
블로그글을 해가 바뀌어서 써보게 되네요.
이번 2주차 스터디 정리가 괜찮게 된다면, 3주차도 열심히 써봐야겠다는 다짐을 하면서 글을 시작합니다!

2주차 벡엔드 스터디는 오프라인으로 진행하였습니다.  
스터디 1부는 1주차 과제의 코드 리뷰, 2부는 NestJs 초보자들을 위한 코드 강의로 진행되었습니다. 다시 한 번 초보자인 저를 도와주신 민선님과 인혁님 정말 감사합니다ㅠㅜ

1주차 스터디로 ORM은 prisma를 이용, NestJs를 공부하기로 하였습니다.

## 1. 코드 리뷰

코드 리뷰 중 기억에 남는 내용을 정리했습니다.

---

## 🌱 민선님 코드 리뷰

### 1.1 Prisma

프로젝트 진행 전에 코드는 카멜케이스(loveGdsc)로 데이터베이스는 스네이크표기(love_gdsc)로 미리 정의하고 시작하였습니다.  
prisma에서는 데이터베이스에

```
@@map("created_at")
```

로 저장이 가능합니다.

### 1.2 Controller

컨트롤러는 들어오는 request를 받고, client에 response를 보내는 역할을 합니다.
@Controller라는 데코레이션을 이용하고 컨트롤러 안에 @Get, @Post와 같은 데코레이션을 이용합니다. controller -> module -> app 을 거처 client에 전달됩니다.

### 1.2.1 http 메소드

위에서 @Get, @Post같은 데코레이션을 이용하는데 @Put과 @Fatch에 차이점이 있습니다.

- put: 전반적으로 다 고칠때 이용합니다.
- fetch: 일부분을 고칠때 이용합니다.  
  put과 fetch를 구분하므로서 유지보수 관점에서 불필요한 데이터의 삭제를 막을 수 있습니다.

### 1.2.2 @Param vs @Body

값을 전달할 때 데이터 종류에 따라 사용하는 명령어가 달랐습니다.

- path parameter: 정제되지 않은 데이터를 호출시 사용
- Query string: 좀더 복잡한 조건에 의해 정재도니 데이터 호출시 사용

## 1.3 Service

서비스 내에는 @Injectable 데코레이터를 이용하여 다른 컴포넌트에서 service를 사용(Injectable)할 수 있도록 합니다. 이를 종속성 주입(Dependency Injection)이라고 합니다. 여기서는 Service를 controller에서 사용할 수 있도록 합니다.  
민선님 코드에서 아쉬운점: 유효성 검사시 데이터를 object를 리턴하거나 type을 따로만들어서 관리하도록 하면 더 좋았을 것 같다.(인혁)

---

## 🌱 인혁님 코드리뷰

### 1.1 미들웨어 - Logger

미들웨어 logger을 사용해서 요청이 들어올 때 마다 loging을 해주었습니다. 콘솔에 로그가 떠서 바로바로 확인할 수 있었습니다. finsih가 되었을 떄만 로그가 나와 불필요한 log가 보이지 않았습니다.

### 1.2 레포지토리 폴더

레포지토리 폴더를 따로 구성하였습니다. 레포지토리를 쓰는 이유는 2가지라고 설명하셨습니다.

1.  데이터베이스 접근구분: 서비스 비지니스 로직에서 사용자 요청시 정보를 요청하는 것과 정보를 찾는 것을 구분할 수 있습니다.(정보가 있는가? 있다면 정보를 찾아주는가?)
2.  코드 유지/보수의 편의성: 데이터베이스나 ORM을 수정할 시 좀 더 편하게 바꿀 수 있습니다.

### 1.3 Controller

컨트롤러에서 Param는 String형태로 가지고 오기 때문에 그냥 넣으면 string형태이므로 int형은 int로 변환해야 합니다.  
민선님은 +문법으로 변환, 인혁님은 parseIntPipes를 이용하여 형변환을 했습니다.

### 1.4 Service

서비스계층에서 에러발생시 @Catch(HttpException)으로 처리하였습니다.

---

## 2. 스터디진행

코드리뷰 이후에는 ppt를 보면서 스터디를 진행했습니다.
여기서는 기억이 잘나지 않아서 부분적으로 적어보겠습니다.

서버에서 데이터를 원하는 것만 필터링해서 가지고 올 때, 어떤 프로퍼티를 가지고 오거나 추가가 되거나 하면 따로 명시를 해줘야하는 많은 불편한 점이 있습니다. 또는 릴레이션으로 다른 테이블에서 데이터를 가지고 올때 많이 번거롭기 때문에 application에서 삭제작업을 할 시 많은 비용이 듭니다.

http 통신의 특성으로는 Connectionless(비연결성)과 stateless(무상태)가 있습니다.  
비연결성은 클라이언트와 서버가 한 번 연결을 맺은 후, 클라이언트 요청에 대해 서버가 응답을 마치면 맺었던 연결을 끊어 버리는 성질을 말합니다.  
무상태는 connectionless로 인해 서버가 클라이언트를 식별할 수 없을 때의 상태를 말합니다. 유저가 사이트 접근시 회원가입, 로그인을 한 후 다른 검색을 하고 다시 접속할 때 계속 로그인의 상태를 유지해주어야 하는데 로그인 상태가 유지되지 않게 되는것입니다. 즉, 매번 새로운 인증을 해야하는 번거로움이 발생합니다.  
stateless에서 이를 해결하는 방법은 대표적으로 2가지가 있습니다.

> Authentication(인증)  
> 상태를 어디에 저장하는지에 따라 2가지로 구분합니다.
>
> - Cookie(쿠키): 브라우저에 상태를 저장합니다. client는 header에 담아서 값을 서버에 전달하고, 브라우저에서 key, 문자열등은 따로 관리합니다.
> - Session(세션): 서버에서 사용자 정보를 저장합니다. 쿠키보다는 안전하며, 서버에 사용자의 정보를 저장하므로 서버의 메모리를 차지하게 되어 동시 접속사 수가 많은 서비스의 경우에는 서버 과부화의 원인이 됩니다.

> Token(토큰)
> 쿠키와 세션의 문제점들을 보완하기 위해 토큰 기반의 인증방식이 도입되었습니다. 토큰 기반의 인증기반의 핵심은 보호할 데이터를 토큰으로 치환하여 원본 데이터 대신 토큰을 사용하는 기술입니다.
>
> - Jwt: 3가지 방식이 있습니다.
> - OAuth: 카카오 로그인시 사용한다고 합니다.

---

2부의 내용도 넣고 싶었지만 성률님보다 잘 쓸 자신이 없기에 성률님의 글을 참고해주세요! 정말 많은걸 배운 스터디였습니다! 다음에는 미리미리 글을 써서 스터디에 있었던 내용들을 모두 정리할 수 있도록 실제 코드에 대한 내용도 담아보겠습니다. 스터디 너무 재미있었고 배우는게 많았습니다! 벡엔드 스터디 파이팅!!!!
